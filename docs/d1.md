# D1 & Drizzle Quick Reference

## D1 Billing Model
- **Charges for rows SCANNED, not returned**
- Reading 10,000 rows to return 10 = pay for 10,000
- Schema operations (ALTER TABLE) = ~50 reads overhead

## Critical Rules

### 1. ALWAYS Index These
```typescript
// Drizzle schema
export const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  email: text('email').notNull(),
  createdAt: integer('created_at', { mode: 'timestamp' }).notNull(),
}, (table) => ({
  // Index any column used in WHERE
  emailIdx: index('idx_users_email').on(table.email),
  // Index any column used in ORDER BY
  createdAtIdx: index('idx_users_created_at').on(table.createdAt),
}));

// For JOINs - index the foreign key
export const posts = sqliteTable('posts', {
  id: integer('id').primaryKey(),
  userId: integer('user_id').notNull(),
}, (table) => ({
  userIdIdx: index('idx_posts_user_id').on(table.userId),
}));
```

### 2. AVOID These Expensive Operations
```typescript
// ❌ COUNT(*) scans entire table even with index
await db.select({ count: count() }).from(users);

// ❌ OFFSET pagination scans all skipped rows
await db.select().from(posts).limit(10).offset(1000);

// ❌ Unindexed WHERE = full table scan
await db.select().from(users).where(eq(users.lastName, 'Smith'));
```

### 3. Use Batch for Multiple Operations
```typescript
// ✅ Single network call, shared overhead
await db.batch([
  db.insert(users).values({ name: 'Alice' }),
  db.insert(users).values({ name: 'Bob' }),
]);
```

### 4. Watch for Join Explosions
```typescript
// ❌ Multiple LEFT JOINs with GROUP BY = Cartesian product explosion
const result = await db
  .select({
    id: posts.id,
    tags: sql`JSON_GROUP_ARRAY(DISTINCT ${tags.name})`,
    comments: sql`JSON_GROUP_ARRAY(DISTINCT ${comments.text})`
  })
  .from(posts)
  .leftJoin(tags, eq(posts.id, tags.postId))
  .leftJoin(comments, eq(posts.id, comments.postId))
  .groupBy(posts.id);
// If post has 10 tags and 20 comments = 200 rows scanned per post!

// ✅ Use separate queries or subqueries instead
const post = await db.select().from(posts).where(eq(posts.id, postId));
const postTags = await db.select().from(tags).where(eq(tags.postId, postId));
const postComments = await db.select().from(comments).where(eq(comments.postId, postId));
```

### 5. UPDATE Trap
```typescript
// ❌ NEVER include ID in update (causes massive reads if has foreign keys)
await db.update(users)
  .set({ id: user.id, name: user.name, email: user.email })
  .where(eq(users.id, user.id));

// ✅ Exclude unchanged ID
await db.update(users)
  .set({ name: user.name, email: user.email })
  .where(eq(users.id, user.id));
```

### 6. D1 Limits
- Max 100 bind parameters per query
- No real transactions (use batch instead)
- COUNT(*) always expensive

## Quick Drizzle + D1 Patterns

```typescript
// Cursor pagination instead of OFFSET
await db.select()
  .from(posts)
  .where(lt(posts.createdAt, cursor))
  .orderBy(desc(posts.createdAt))
  .limit(10);

// Composite index for multi-column WHERE
export const orders = sqliteTable('orders', {
  userId: integer('user_id'),
  status: text('status'),
}, (table) => ({
  userStatusIdx: index('idx_orders_user_status').on(table.userId, table.status),
}));
```

## Remember
- **No index = full scan = huge bill**
- **Every WHERE needs an index**
- **Every foreign key needs an index**
- **Avoid COUNT(*) and OFFSET**

Resources:
- https://rxliuli.com/blog/journey-to-optimize-cloudflare-d1-database-queries/
- https://github.com/drizzle-team/drizzle-orm/issues/2479